/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n(function () {\n  // Configuration Variables\n  var config = _objectSpread({\n    percentages: [10, 20, 30, 40, 50, 60, 70, 80, 90],\n    tms: 'gtm',\n    datalayerVariableNames: ['auto'],\n    debug: false\n  }, window.__htmlMediaElementsTrackingConfig); // We'll hold the current media elements statuses on this object\n\n\n  var HTMLMediaElementStatus = {}; // If the dataLayer Variable names is set to 'auto' let's find out the current\n  // dataLayer Avaialable in the page\n\n  if (window.google_tag_manager && config.tms === 'gtm' && !config.dataLayer && config.datalayerVariableNames[0] === 'auto') {\n    config.datalayerVariableNames = Object.entries(window.google_tag_manager).filter(function (e) {\n      if (e[1].gtmDom) return e;\n      return false;\n    }).map(function (e) {\n      return e[0];\n    });\n  } // Helper Function to check and element visibility within the viewport\n\n\n  var elementIsVisible = function elementIsVisible(elem) {\n    var bounds = elem.getBoundingClientRect();\n\n    if (bounds.top < 0 || bounds.left < 0 || bounds.bottom > (window.innerHeight || document.documentElement.clientHeight) || bounds.right > (window.innerWidth || document.documentElement.clientWidth)) {\n      return false;\n    }\n\n    return true;\n  }; // Function to push data to the TMS\n\n\n  var pushData = function pushData(data) {\n    switch (config.tms) {\n      case 'gtm':\n        if (config.datalayerVariableNames) {\n          config.datalayerVariableNames.forEach(function (e) {\n            try {\n              if (config.debug) console.info(\"PUSHING DATA TO GTM dataLayer > \".concat(e), data);\n              window[e].push(data); // eslint-disable-next-line no-empty\n            } catch (err) {}\n          });\n        } else if (config.debug) console.error('HTML5 Media Tracker: Defined TMS not found');\n\n        if (config.debug) {\n          console.log(data.gtm.audioStatus || data.gtm.videoStatus);\n          console.info(JSON.stringify(data.gtm, null, '\\t'));\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  }; // Event Handler Function\n\n\n  var eventHandler = function eventHandler(e) {\n    var _gtm;\n\n    var mediaType = e.target.nodeName.toLowerCase();\n    var pushModel = {\n      event: ['gtm', mediaType].join('.'),\n      gtm: (_gtm = {\n        elementClasses: e.target.className,\n        elementId: e[\"for\"] || e.target.id || '',\n        elementTarget: e.target,\n        elementUrl: e.baseURI || document.location.href\n      }, _defineProperty(_gtm, \"\".concat(mediaType, \"Provider\"), 'html5'), _defineProperty(_gtm, \"\".concat(mediaType, \"Status\"), e.type), _defineProperty(_gtm, \"\".concat(mediaType, \"Url\"), e.target.currentSrc), _defineProperty(_gtm, \"\".concat(mediaType, \"Title\"), decodeURIComponent(e.target.currentSrc.split('/')[e.target.currentSrc.split('/').length - 1])), _defineProperty(_gtm, \"\".concat(mediaType, \"Duration\"), Math.round(e.target.duration)), _defineProperty(_gtm, \"\".concat(mediaType, \"CurrentTime\"), Math.round(e.target.currentTime)), _defineProperty(_gtm, \"\".concat(mediaType, \"Percent\"), Math.floor(100 * e.target.currentTime / e.target.duration)), _defineProperty(_gtm, \"\".concat(mediaType, \"Visible\"), elementIsVisible(e.target)), _defineProperty(_gtm, \"\".concat(mediaType, \"IsMuted\"), e.target.muted), _defineProperty(_gtm, \"\".concat(mediaType, \"PlaybackRate\"), e.target.playbackRate), _defineProperty(_gtm, \"\".concat(mediaType, \"Loop\"), e.target.loop), _defineProperty(_gtm, \"\".concat(mediaType, \"Volume\"), e.target.volume), _defineProperty(_gtm, \"\".concat(mediaType, \"NetworkState\"), e.target.networkState), _gtm)\n    }; // Current supported events\n\n    switch (e.type) {\n      case 'volumechange':\n        // Only track when the video is muted, either by lowering the volume to 0 or setting the muted switch\n        if (pushModel.gtm[\"\".concat(mediaType, \"IsMuted\")] === true || pushModel.gtm[\"\".concat(mediaType, \"Volume\")] === 0) {\n          HTMLMediaElementStatus[e.target.id].muted = true;\n          pushModel.gtm[\"\".concat(mediaType, \"Status\")] = 'mute';\n          pushData(pushModel);\n        }\n\n        break;\n\n      case 'seeked':\n        // When user goes fwd, or rwd\n        pushModel.gtm[\"\".concat(mediaType, \"Status\")] = 'seek';\n        pushData(pushModel);\n        break;\n      // This event type is sent everytime the player updated it's current time,\n      // We're using for the % of the video played.\n\n      case 'timeupdate':\n        console.log(HTMLMediaElementStatus[e.target.id].progress_markers);\n        Object.entries(HTMLMediaElementStatus[e.target.id].progress_markers).forEach(function (progressMarkers) {\n          var _progressMarkers = _slicedToArray(progressMarkers, 1),\n              k = _progressMarkers[0];\n\n          if (pushModel.gtm[\"\".concat(mediaType, \"Percent\")] >= k && k > HTMLMediaElementStatus[e.target.id].greatest_marker) {\n            HTMLMediaElementStatus[e.target.id].greatest_marker = k;\n          }\n        }); // current bucket hasn't been already sent to GA?, let's push it\n\n        if (HTMLMediaElementStatus[e.target.id].greatest_marker && !HTMLMediaElementStatus[e.target.id].progress_markers[HTMLMediaElementStatus[e.target.id].greatest_marker]) {\n          HTMLMediaElementStatus[e.target.id].progress_markers[HTMLMediaElementStatus[e.target.id].greatest_marker] = true;\n          pushModel.gtm[\"\".concat(mediaType, \"Status\")] = 'progress';\n          pushModel.gtm[\"\".concat(mediaType, \"Percent\")] = HTMLMediaElementStatus[e.target.id].greatest_marker;\n          pushData(pushModel);\n        }\n\n        HTMLMediaElementStatus[e.target.id].currentTime = Math.round(e.target.currentTime);\n        break;\n\n      case 'play':\n        // We only want to push the play event once, and report is as \"start\"\n        if (HTMLMediaElementStatus[e.target.id].play_event === false) {\n          pushModel.gtm[\"\".concat(mediaType, \"Status\")] = 'start';\n          pushData(pushModel);\n        }\n\n        HTMLMediaElementStatus[e.target.id].play_event = true;\n        break;\n\n      case 'pause':\n        // Pause shouldn't be firing before ended or seeking events\n        if (pushModel.gtm[\"\".concat(mediaType, \"Status\")] !== 100 && e.target.seeking !== true && Math.round(e.target.currentTime) !== Math.round(e.target.duration)) {\n          pushData(pushModel);\n        }\n\n        break;\n\n      case 'ended':\n        pushData(pushModel);\n        break;\n\n      case 'error':\n        pushModel.gtm[\"\".concat(mediaType, \"ErrorCode\")] = e.target.error.code;\n        pushModel.gtm[\"\".concat(mediaType, \"ErrorMessage\")] = e.target.error.message;\n        pushData(pushModel);\n        break;\n\n      default:\n        break;\n    }\n  }; // Grab all Audio/Video Media Elements\n\n\n  var HTMLMediaElements = [].concat(_toConsumableArray(document.getElementsByTagName('audio')), _toConsumableArray(document.getElementsByTagName('video'))); // Loop elements, fill the status info and set the listeners\n\n  HTMLMediaElements.forEach(function (element) {\n    var elementTagId;\n\n    if (!element.getAttribute('id')) {\n      // The element has no id, let's set a random one.\n      elementTagId = \"html_media_element_\".concat(Math.random().toString(36).slice(2));\n      element.setAttribute('id', elementTagId);\n    } else {\n      elementTagId = element.getAttribute('id');\n    } // Video Status Object declaration\n\n\n    HTMLMediaElementStatus[elementTagId] = {\n      progress_markers: {},\n      type: element.nodeName.toLowerCase(),\n      greatest_marker: 0,\n      play_event: false,\n      muted: false,\n      currentTime: 0\n    }; // Build up Markers\n\n    config.percentages.forEach(function (e) {\n      HTMLMediaElementStatus[elementTagId].progress_markers[e] = false;\n    }); // Add the listeners\n\n    element.addEventListener('play', eventHandler, false);\n    element.addEventListener('pause', eventHandler, false);\n    element.addEventListener('ended', eventHandler, false);\n    element.addEventListener('timeupdate', eventHandler, false);\n    element.addEventListener('seeked', eventHandler, false);\n    element.addEventListener('volumechange', eventHandler, false);\n    element.addEventListener('error', eventHandler, false);\n  });\n})();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });